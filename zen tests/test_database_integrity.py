"""
Script de v√©rification de l'int√©grit√© de la base de donn√©es Neuro-Bot
"""
import os
import sqlite3
import sys
from datetime import datetime
from pathlib import Path

# Ajouter le r√©pertoire parent au path pour importer les modules
sys.path.append(str(Path(__file__).parent.parent))

from config import config, logger
from database import get_db_connection, db_manager


def check_database_exists():
    """V√©rifie si la base de donn√©es existe"""
    print(f"üîç V√©rification de l'existence de la base de donn√©es...")
    print(f"üìç Chemin configur√©: {config.DB_PATH}")
    
    if os.path.exists(config.DB_PATH):
        size = os.path.getsize(config.DB_PATH)
        print(f"‚úÖ Base de donn√©es trouv√©e (taille: {size} bytes)")
        return True
    else:
        print(f"‚ùå Base de donn√©es non trouv√©e √†: {config.DB_PATH}")
        return False


def check_database_structure():
    """V√©rifie la structure de la base de donn√©es"""
    print(f"\nüîç V√©rification de la structure de la base de donn√©es...")
    
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            
            # V√©rifier les tables existantes
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = [row[0] for row in cursor.fetchall()]
            print(f"üìã Tables trouv√©es: {tables}")
            
            expected_tables = ['memory', 'facts']
            missing_tables = [table for table in expected_tables if table not in tables]
            
            if missing_tables:
                print(f"‚ùå Tables manquantes: {missing_tables}")
                return False
            else:
                print(f"‚úÖ Toutes les tables requises sont pr√©sentes")
            
            # V√©rifier la structure de chaque table
            for table in expected_tables:
                print(f"\nüìä Structure de la table '{table}':")
                cursor.execute(f"PRAGMA table_info({table})")
                columns = cursor.fetchall()
                for col in columns:
                    print(f"  - {col[1]} ({col[2]}) {'NOT NULL' if col[3] else 'NULL'} {'PRIMARY KEY' if col[5] else ''}")
            
            # V√©rifier les index
            print(f"\nüîó Index disponibles:")
            cursor.execute("SELECT name, tbl_name FROM sqlite_master WHERE type='index' AND name NOT LIKE 'sqlite_%'")
            indexes = cursor.fetchall()
            for idx in indexes:
                print(f"  - {idx[0]} sur table {idx[1]}")
            
            return True
            
    except Exception as e:
        print(f"‚ùå Erreur lors de la v√©rification de la structure: {e}")
        return False


def check_database_integrity():
    """V√©rifie l'int√©grit√© de la base de donn√©es avec PRAGMA integrity_check"""
    print(f"\nüîç V√©rification de l'int√©grit√© de la base de donn√©es...")
    
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("PRAGMA integrity_check")
            result = cursor.fetchone()[0]
            
            if result == "ok":
                print(f"‚úÖ Int√©grit√© de la base de donn√©es: OK")
                return True
            else:
                print(f"‚ùå Probl√®me d'int√©grit√© d√©tect√©: {result}")
                return False
                
    except Exception as e:
        print(f"‚ùå Erreur lors de la v√©rification d'int√©grit√©: {e}")
        return False


def get_database_statistics():
    """Affiche les statistiques de la base de donn√©es"""
    print(f"\nüìä Statistiques de la base de donn√©es...")
    
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            
            # Statistiques de la table memory
            cursor.execute("SELECT COUNT(*) FROM memory")
            memory_count = cursor.fetchone()[0]
            print(f"üí≠ Entr√©es dans 'memory': {memory_count}")
            
            if memory_count > 0:
                cursor.execute("SELECT COUNT(DISTINCT user_id) FROM memory")
                unique_users_memory = cursor.fetchone()[0]
                print(f"üë• Utilisateurs uniques dans 'memory': {unique_users_memory}")
                
                cursor.execute("SELECT MIN(timestamp), MAX(timestamp) FROM memory")
                min_date, max_date = cursor.fetchone()
                print(f"üìÖ P√©riode couverte (memory): {min_date} ‚Üí {max_date}")
            
            # Statistiques de la table facts
            cursor.execute("SELECT COUNT(*) FROM facts")
            facts_count = cursor.fetchone()[0]
            print(f"üìù Entr√©es dans 'facts': {facts_count}")
            
            if facts_count > 0:
                cursor.execute("SELECT COUNT(DISTINCT user_id) FROM facts")
                unique_users_facts = cursor.fetchone()[0]
                print(f"üë• Utilisateurs uniques dans 'facts': {unique_users_facts}")
                
                cursor.execute("SELECT MIN(timestamp), MAX(timestamp) FROM facts")
                min_date, max_date = cursor.fetchone()
                print(f"üìÖ P√©riode couverte (facts): {min_date} ‚Üí {max_date}")
            
            # Taille de la base de donn√©es
            cursor.execute("PRAGMA page_count")
            page_count = cursor.fetchone()[0]
            cursor.execute("PRAGMA page_size")
            page_size = cursor.fetchone()[0]
            db_size = page_count * page_size
            print(f"üíæ Taille de la base: {db_size} bytes ({db_size / 1024:.2f} KB)")
            
    except Exception as e:
        print(f"‚ùå Erreur lors de la r√©cup√©ration des statistiques: {e}")


def check_data_consistency():
    """V√©rifie la coh√©rence des donn√©es"""
    print(f"\nüîç V√©rification de la coh√©rence des donn√©es...")
    
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            
            # V√©rifier les entr√©es avec des champs vides
            cursor.execute("SELECT COUNT(*) FROM memory WHERE user_id = '' OR user_input = '' OR bot_response = ''")
            empty_memory = cursor.fetchone()[0]
            if empty_memory > 0:
                print(f"‚ö†Ô∏è  Entr√©es 'memory' avec champs vides: {empty_memory}")
            else:
                print(f"‚úÖ Aucune entr√©e 'memory' avec champs vides")
            
            cursor.execute("SELECT COUNT(*) FROM facts WHERE user_id = '' OR fact = ''")
            empty_facts = cursor.fetchone()[0]
            if empty_facts > 0:
                print(f"‚ö†Ô∏è  Entr√©es 'facts' avec champs vides: {empty_facts}")
            else:
                print(f"‚úÖ Aucune entr√©e 'facts' avec champs vides")
            
            # V√©rifier les timestamps invalides
            cursor.execute("SELECT COUNT(*) FROM memory WHERE timestamp IS NULL")
            null_timestamps_memory = cursor.fetchone()[0]
            if null_timestamps_memory > 0:
                print(f"‚ö†Ô∏è  Entr√©es 'memory' avec timestamp NULL: {null_timestamps_memory}")
            else:
                print(f"‚úÖ Tous les timestamps 'memory' sont valides")
            
            cursor.execute("SELECT COUNT(*) FROM facts WHERE timestamp IS NULL")
            null_timestamps_facts = cursor.fetchone()[0]
            if null_timestamps_facts > 0:
                print(f"‚ö†Ô∏è  Entr√©es 'facts' avec timestamp NULL: {null_timestamps_facts}")
            else:
                print(f"‚úÖ Tous les timestamps 'facts' sont valides")
            
    except Exception as e:
        print(f"‚ùå Erreur lors de la v√©rification de coh√©rence: {e}")


def test_database_operations():
    """Teste les op√©rations de base sur la base de donn√©es"""
    print(f"\nüîç Test des op√©rations de base de donn√©es...")
    
    test_user_id = "test_integrity_check"
    test_input = "Test d'int√©grit√©"
    test_response = "R√©ponse de test"
    test_fact = "Fait de test pour v√©rification"
    
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            
            # Test d'insertion dans memory
            cursor.execute("""
                INSERT INTO memory (user_id, user_input, bot_response)
                VALUES (?, ?, ?)
            """, (test_user_id, test_input, test_response))
            
            # Test de lecture
            cursor.execute("SELECT * FROM memory WHERE user_id = ?", (test_user_id,))
            result = cursor.fetchone()
            if result:
                print(f"‚úÖ Test d'insertion/lecture 'memory': OK")
            else:
                print(f"‚ùå Test d'insertion/lecture 'memory': √âCHEC")
            
            # Test d'insertion dans facts
            cursor.execute("""
                INSERT INTO facts (user_id, fact)
                VALUES (?, ?)
            """, (test_user_id, test_fact))
            
            # Test de lecture facts
            cursor.execute("SELECT * FROM facts WHERE user_id = ?", (test_user_id,))
            result = cursor.fetchone()
            if result:
                print(f"‚úÖ Test d'insertion/lecture 'facts': OK")
            else:
                print(f"‚ùå Test d'insertion/lecture 'facts': √âCHEC")
            
            # Nettoyage des donn√©es de test
            cursor.execute("DELETE FROM memory WHERE user_id = ?", (test_user_id,))
            cursor.execute("DELETE FROM facts WHERE user_id = ?", (test_user_id,))
            conn.commit()
            
            print(f"‚úÖ Donn√©es de test nettoy√©es")
            
    except Exception as e:
        print(f"‚ùå Erreur lors du test des op√©rations: {e}")


def main():
    """Fonction principale de v√©rification"""
    print("=" * 60)
    print("ü§ñ V√âRIFICATION DE L'INT√âGRIT√â DE LA BASE DE DONN√âES NEURO-BOT")
    print("=" * 60)
    
    # V√©rifications s√©quentielles
    checks = [
        check_database_exists,
        check_database_structure,
        check_database_integrity,
        check_data_consistency,
        test_database_operations
    ]
    
    results = []
    for check in checks:
        try:
            result = check()
            results.append(result)
        except Exception as e:
            print(f"‚ùå Erreur inattendue dans {check.__name__}: {e}")
            results.append(False)
    
    # Affichage des statistiques
    get_database_statistics()
    
    # R√©sum√© final
    print("\n" + "=" * 60)
    print("üìã R√âSUM√â DE LA V√âRIFICATION")
    print("=" * 60)
    
    passed = sum(1 for r in results if r)
    total = len(results)
    
    if passed == total:
        print(f"‚úÖ Toutes les v√©rifications sont pass√©es ({passed}/{total})")
        print("üéâ La base de donn√©es est en bon √©tat !")
    else:
        print(f"‚ö†Ô∏è  {total - passed} v√©rification(s) ont √©chou√© sur {total}")
        print("üîß Des actions correctives peuvent √™tre n√©cessaires")
    
    print(f"\nüìÖ V√©rification effectu√©e le: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")


if __name__ == "__main__":
    main()